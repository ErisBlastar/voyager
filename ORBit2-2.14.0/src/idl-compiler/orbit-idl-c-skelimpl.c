#include "config.h"

#include "orbit-idl-c-backend.h"

/* This file copied from the old IDL compiler orbit-c-skelimpl.c, with minimal changes. */

static void orbit_cbe_write_skelimpl(FILE *outfile, IDL_tree tree, const char *hdrname);

void
orbit_idl_output_c_skelimpl(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
	orbit_cbe_write_skelimpl(ci->fh, tree, ci->base_name);
}

#include <ctype.h>
#include <glib.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include <errno.h>

/* Used to count the static methods of a class. This is kind of a hack.
   I would love to put it into CBESkelImplInfo but his struct is copied
   everywhere and given as a copy to subprocedures. */ 
static gulong ulNumStaticMethods[10]; 
static gulong ulInstanceVarSize[10]; 
static GString *gsMetaClassName[10];
static gulong ulNumOverridenMethods[10]; 
static gulong ulNumParentsInChain[10]; 

static int ulCurInterface=0;
static int whichPass;

/* Abbreviations used here:
   "cbe" stands for "C backend"
   "hdr" -> "header" (duh :)
   "of" -> "output file"
   "ns" -> "name space"
*/

typedef struct {
  FILE *of;
  IDL_tree tree;
  enum { PASS_VOYAGER_INSTANCE, PASS_VOYAGER_GETDATA, PASS_VOYAGER_CLSDATA, PASS_VOYAGER_PARMCHECK,
         PASS_SERVANTS, PASS_PROTOS, PASS_EPVS, PASS_VEPVS,
         PASS_IMPLSTUBS, PASS_VOYAGER_OVERRIDEN_METHODS, PASS_VOYAGER_OVERRIDEN_METHODTAB,
         PASS_VOYAGER_STATICMETHODS, PASS_VOYAGER_METACLASS, PASS_VOYAGER_CLASSINFO, PASS_VOYAGER_NEWCLASS,
         PASS_LAST } pass;
} CBESkelImplInfo;

typedef struct {
  FILE *of;
  IDL_tree realif;
  char* chrOverridenMethodName;
} InheritedOutputInfo;

typedef struct {
  FILE *of;
  IDL_tree realif;
  char* chrOverridenMethodName;
  char* chrClassName;
} InheritedOutputInfo2;

static const char *passnames[] = {
  "Voyager object instance data",
  "Voyager GetData macros ", 
  "Voyager class data structures",
  "Voyager parameter check",
  "App-specific servant structures",
  "Implementation stub prototypes",
  "epv structures",
  "vepv structures",
  "Stub implementations",
  "Voyager overriden methods",
  "Voyager overriden method table",
  "Voyager static methods",
  "Voyager explicit metaclass (if any)",
  "Voyager class information structure",
  "Voyager class creation function",
  "Boohoo!"
};

static void orbit_cbe_ski_process_piece(CBESkelImplInfo *ski);
static void cbe_ski_do_list(CBESkelImplInfo *ski);
static void cbe_ski_do_inherited_attr_dcl(CBESkelImplInfo *ski, IDL_tree current_interface);
static void cbe_ski_do_attr_dcl(CBESkelImplInfo *ski);
static void cbe_ski_do_inherited_op_dcl(CBESkelImplInfo *ski, IDL_tree current_interface);
static void cbe_ski_do_op_dcl(CBESkelImplInfo *ski);
static void cbe_ski_do_param_dcl(CBESkelImplInfo *ski);
static void cbe_ski_do_interface(CBESkelImplInfo *ski);
static void cbe_ski_do_module(CBESkelImplInfo *ski);

static void cbe_ski_do_voyager_instance_vars(CBESkelImplInfo *ski);
static void cbe_ski_do_voyager_getdata_macros(CBESkelImplInfo *ski);
static void cbe_ski_do_voyager_classinfo_structure(CBESkelImplInfo *ski, gchar* className);

static void
orbit_cbe_write_skelimpl(FILE *outfile, IDL_tree tree, const char *hdrname)
{
	CBESkelImplInfo ski = {NULL, NULL, PASS_VOYAGER_INSTANCE};

	ski.of = outfile;
	ski.tree = tree;

	g_return_if_fail(IDL_NODE_TYPE(tree) == IDLN_LIST);

	fprintf(outfile, "/* This is a template file generated by command */\n");
	fprintf(outfile, "/* orbit-idl-2 --skeleton-impl %s.idl */\n", hdrname);
	fprintf(outfile, "/* User must edit this file, inserting servant  */\n");
	fprintf(outfile, "/* specific code between markers. */\n\n");

	fprintf(outfile, "/* Implemented in %s */\n\n", __FILE__);

	fprintf(outfile, "#include \"%s.h\"\n", hdrname);

    ulNumStaticMethods[ulCurInterface]=0;
    ulInstanceVarSize[ulCurInterface]=0; 
    ulNumOverridenMethods[ulCurInterface]=0;
    ulNumParentsInChain[ulCurInterface]=0;

	for(whichPass=ski.pass = PASS_VOYAGER_INSTANCE /*PASS_SERVANTS*/; ski.pass < PASS_LAST; ski.pass++) {
		fprintf(ski.of, "\n/*** %s ***/\n\n", passnames[ski.pass]);
		orbit_cbe_ski_process_piece(&ski);
	}
    fprintf(outfile, "\n#endif /* NOM_CLASS_IMPLEMENTATION_FILE */\n");
}

/*
  Worker function for outputting the name of a class introducing some method.
  Called by VoyagerOutputIntroducingClass();
 */
static
void VoyagerDoOutputIntroducingClass(IDL_tree curif, InheritedOutputInfo *ioi)
{
  char *id;
  IDL_tree curitem;
  char* overridenMethodName;

  if(curif == ioi->realif)
    return;

  overridenMethodName=ioi->chrOverridenMethodName;

  id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(curif).ident), "_", 0);

  for(curitem = IDL_INTERFACE(curif).body; curitem; curitem = IDL_LIST(curitem).next) {
    IDL_tree curop = IDL_LIST(curitem).data;

    switch(IDL_NODE_TYPE(curop)) {
    case IDLN_OP_DCL:
      {
        /* Check if the current method (introduced by some parent) is the one to be
           overriden. */
        if(!strcmp(overridenMethodName, IDL_IDENT(IDL_OP_DCL(curop).ident).str)){
          fprintf(ioi->of, "%s", id);
        }
        break;
      }
	default:
	  break;
    }
  }
  g_free(id);
}

/*
  Output the name of a class introducing an overriden method.
*/
static
void VoyagerOutputIntroducingClass(IDL_tree tmptree, CBESkelImplInfo *ski, GString *gstr)
{
  if(IDL_INTERFACE(tmptree).inheritance_spec) {
    InheritedOutputInfo ioi;
    
    ioi.of = ski->of;
    ioi.realif = tmptree;
    ioi.chrOverridenMethodName=gstr->str;
    IDL_tree_traverse_parents(IDL_INTERFACE(tmptree).inheritance_spec,
                              (GFunc)VoyagerDoOutputIntroducingClass, &ioi);
  }
}


static
void VoyagerOutputParentMethodSpec(IDL_tree curif, InheritedOutputInfo *ioi)
{
  char *id;
  IDL_tree curitem;
  char* overridenMethodName;

  if(curif == ioi->realif)
    return;

  overridenMethodName=ioi->chrOverridenMethodName;

  id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(curif).ident), "_", 0);

  for(curitem = IDL_INTERFACE(curif).body; curitem; curitem = IDL_LIST(curitem).next) {
    IDL_tree curop = IDL_LIST(curitem).data;

    switch(IDL_NODE_TYPE(curop)) {
    case IDLN_OP_DCL:
      {
        /* Check if the current method (introduced by some parent) is the one to be
           overriden. */
        if(!strcmp(overridenMethodName, IDL_IDENT(IDL_OP_DCL(curop).ident).str)){
          //nomTD_NOMTest2_nomTestFunc_NOMTest2
          fprintf(ioi->of, "nomTD_%s_%s",
                  id, IDL_IDENT(IDL_OP_DCL(curop).ident).str);
        }
        break;
      }
	default:
	  break;
    }
  }
  g_free(id);
}

static
void VoyagerWriteParamsForParentCall(IDL_tree curif, InheritedOutputInfo *ioi)
{
  IDL_tree curitem;
  char* overridenMethodName;

  if(curif == ioi->realif)
    return;

  overridenMethodName=ioi->chrOverridenMethodName;

  for(curitem = IDL_INTERFACE(curif).body; curitem; curitem = IDL_LIST(curitem).next) {
    IDL_tree curop = IDL_LIST(curitem).data;

    switch(IDL_NODE_TYPE(curop)) {
    case IDLN_OP_DCL:
      {
        /* Check if the current method (introduced by some parent) is the one to be
           overriden. */
        if(!strcmp(overridenMethodName, IDL_IDENT(IDL_OP_DCL(curop).ident).str)){
          IDL_tree  sub;

          for (sub = IDL_OP_DCL (curop).parameter_dcls; sub; sub = IDL_LIST (sub).next) {
            IDL_tree parm = IDL_LIST (sub).data;
            fprintf (ioi->of, "%s, ", IDL_IDENT (IDL_PARAM_DCL (parm).simple_declarator).str);
          }
        }
        break;
      }
	default:
	  break;
    }
  }
}

/*
  This function is called for each parent to check if the current parent introduced the
  overriden method. If yes, the parameter info is taken from this parent and put into the
  file.
 */
static
void VoyagerDoWriteOverridenMethodDeclaration(IDL_tree curif, InheritedOutputInfo2 *ioi)
{
  IDL_tree curitem;
  char* overridenMethodName;

  if(curif == ioi->realif)
    return;

  overridenMethodName=ioi->chrOverridenMethodName;

  for(curitem = IDL_INTERFACE(curif).body; curitem; curitem = IDL_LIST(curitem).next) {
    IDL_tree curop = IDL_LIST(curitem).data;

    switch(IDL_NODE_TYPE(curop)) {
    case IDLN_OP_DCL:
      {
        /* Check if the current method (introduced by some parent) is the one to be
           overriden. */
        if(!strcmp(overridenMethodName, IDL_IDENT(IDL_OP_DCL(curop).ident).str)){
          IDL_tree  sub;
          
          g_assert (IDL_NODE_TYPE(curop) == IDLN_OP_DCL);

          /* return typespec */
          orbit_cbe_write_param_typespec (ioi->of, curop);
          
          /* The methodname */
          fprintf (ioi->of, " %s%s_%s", "NOMLINK impl_",
                   ioi->chrClassName, overridenMethodName);
          
          fprintf (ioi->of, "(%s* nomSelf, ", ioi->chrClassName);
          
          /* Write the params including the typespec */          
          for (sub = IDL_OP_DCL (curop).parameter_dcls; sub; sub = IDL_LIST (sub).next) {
            IDL_tree parm = IDL_LIST (sub).data;
            
            orbit_cbe_write_param_typespec (ioi->of, parm);
            
            fprintf (ioi->of, " %s, ", IDL_IDENT (IDL_PARAM_DCL (parm).simple_declarator).str);
          }
        }
        break;
      }
	default:
	  break;
    }
  }
}

/*
  Overriden methods are introduced by some parent class. This function gets the parent node and
  climbs down the list of classes to find the one introducing the method. A support function called
  for every node while traversing actually writes the info.
*/ 
static void
VoyagerWriteOverridenMethodDeclaration(FILE       *of, IDL_tree    op,
                                     const char *nom_prefix,
                                     gboolean    for_epv)
{
  char     *id;
  char * id2;
  char * ptr;
  IDL_tree tmptree;

  g_assert (IDL_NODE_TYPE(op) == IDLN_OP_DCL);

  id = IDL_ns_ident_to_qstring (
                                IDL_IDENT_TO_NS (IDL_INTERFACE (
                                IDL_get_parent_node (op, IDLN_INTERFACE, NULL)).ident), "_", 0);

  id2=g_strdup(IDL_IDENT (IDL_OP_DCL (op).ident).str);
  if((ptr=strstr(id2, NOM_OVERRIDE_STRING))!=NULL)
    *ptr='\0';
  
  tmptree = IDL_get_parent_node(op, IDLN_INTERFACE, NULL);
  
  if(IDL_INTERFACE(tmptree).inheritance_spec) {
    InheritedOutputInfo2 ioi;
    
    ioi.of = of;
    ioi.realif = tmptree;
    ioi.chrOverridenMethodName=id2;
    ioi.chrClassName=id; /* The current class name. In the called function the parent is searched introducing the method.
                            When this parent is found, the current class info isn't easy to get again but it's needed. */

    IDL_tree_traverse_parents(IDL_INTERFACE(tmptree).inheritance_spec, (GFunc)VoyagerDoWriteOverridenMethodDeclaration, &ioi);
  }
  g_free(id2);
  g_free(id);
}

/*
  The name of our meta class is encoded as a constant. We go over all the constants found during
  IDL parsing and check for a special marker string in the name.
 */
static void
VoyagerExtractMetaClass(CBESkelImplInfo *ski)
{
  char    *id;
  IDL_tree ident;
  IDL_tree intf;


  if(PASS_VOYAGER_METACLASS==ski->pass)
    {
      ident = IDL_CONST_DCL (ski->tree).ident;
      intf = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, NULL);

      id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS (ident), "_", 0);

      if(IDLN_STRING==IDL_NODE_TYPE(IDL_CONST_DCL(ski->tree).const_exp))
        {
          //  printf(" %d --- > %s\n", __LINE__,IDL_IDENT(ident).str);
          /* Our metaclass info is a string */
          if(strstr( IDL_IDENT(ident).str, NOM_METACLASS_STRING))
            {
              gsMetaClassName[ulCurInterface]=g_string_new(NULL);
              g_string_printf(gsMetaClassName[ulCurInterface], "%s", IDL_STRING(IDL_CONST_DCL(ski->tree).const_exp).value);
              //    printf(" %d    --- > %s %s (%x)\n",
              //     __LINE__, id, IDL_STRING(IDL_CONST_DCL(ski->tree).const_exp).value, gsMetaClassName[ulCurInterface]);
            }
        }
      g_free(id);
    }/* PASS_VOYAGER_...*/
}

/*
  This function creates a define for methods with parameter check at the top of the *.ih file
  to enable the check function whichis sourrounded by '#ifdef/#endif.
  Note that this function does not create any checking code. 

  For methods which should have parameter checks (specified by a special macro in the IDL file)
  a constant string is specified. The method name is encoded in the constants name while the string
  holds all the info about the parameters to check.
  We go over all the constants found during IDL parsing and check for a special marker string in the
  name.
 */
static void
VoyagerCreateParamCheckDefines(CBESkelImplInfo *ski)
{
  char    *id;
  IDL_tree ident;
  IDL_tree intf;


  if(PASS_VOYAGER_PARMCHECK==ski->pass)
    {
      ident = IDL_CONST_DCL (ski->tree).ident;
      intf = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, NULL);

      id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS (ident), "_", 0);

      if(IDLN_STRING==IDL_NODE_TYPE(IDL_CONST_DCL(ski->tree).const_exp))
        {
          gchar *ptr;
          //  printf(" %d --- > %s\n", __LINE__,IDL_IDENT(ident).str);
          /* Our parameter info is a string */
          ptr=strstr( id /*IDL_IDENT(ident).str*/, NOM_PARMCHECK_STRING);
          if(ptr)
            {
              *ptr='\0';
              //printf(" %d    --- > %s %s Params: %s\n",
              //__LINE__, id, IDL_IDENT(ident).str, IDL_STRING(IDL_CONST_DCL(ski->tree).const_exp).value);
              fprintf(ski->of, "#ifndef %s_ParmCheck\n", id);
              fprintf(ski->of, "#define %s_ParmCheck\n", id);
              fprintf(ski->of, "#endif\n");
              *ptr='_';
            }
        }
      g_free(id);
    }/* PASS_VOYAGER_...*/
}

/*
  Output a generic function for checking the object pointer.
 */
static void
VoyagerCreateObjectCheckFunction(char *id2, CBESkelImplInfo *ski)
{
#if 0
  if(PASS_VOYAGER_PARMCHECK==ski->pass)
    {

      char *id, *id2;
      IDL_tree curitem;
      int level;
      GString *gstr;

      curitem = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, &level);
      g_assert(curitem);

      id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_OP_DCL(ski->tree).ident), "_", 0);    
      id2 = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(curitem).ident), "_", 0);

      gstr=g_string_new(IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);
#endif

      /* Output a function for checking the parameters. Note that we only
         check the object pointer. */
      fprintf(ski->of, "\n/* Function to check if an object is valid before calling a method on it */\n");
      fprintf(ski->of, "#ifdef NOM_NO_PARAM_CHECK /* Disabled by now because not working */\n");
      fprintf(ski->of, "NOMEXTERN ");                
      fprintf(ski->of, "gboolean NOMLINK objectCheckFunc_%s(%s *nomSelf, gchar* chrMethodName)\n",
              id2, id2);                
      fprintf(ski->of, "{\n");
      
      fprintf(ski->of, "if(!nomIsObj(nomSelf) || !_nomIsANoClsCheck(nomSelf , %sClassData.classObject, NULLHANDLE))\n", id2);
      fprintf(ski->of, "  {\n");
      fprintf(ski->of, "  nomPrintObjectPointerError(nomSelf, \"%s\", chrMethodName);\n", id2);
      fprintf(ski->of, "  g_message(\"Note that NULL is returned for the call (if the method returns a value). This may not be correct. Use the NOMPARMCHECK() macro to specify default return values for methods.\");\n");
      fprintf(ski->of, "  return FALSE;\n");
      fprintf(ski->of, "  }\n");
      fprintf(ski->of, "  return TRUE;\n");
      fprintf(ski->of, "}\n");
      fprintf(ski->of, "#endif\n");
      //      g_free(id); g_free(id2);
      // }   
}


/*
  This function outputs the parameter type of methods without the 'const'
  qualifier.
 */
static void VoyagerOutputParamTypes(CBESkelImplInfo *ski)
{
  if(IDLN_PARAM_DCL!=IDL_NODE_TYPE(ski->tree))
    return;

  orbit_cbe_voyager_write_param_typespec(ski->of, ski->tree);  
}

static void
orbit_cbe_ski_process_piece(CBESkelImplInfo *ski)
{
	/* I'm not implementing this as an array of function pointers
	   because we may want to do special logic for particular cases in
	   the future. Hope this is clear enough. -ECL */


	switch(IDL_NODE_TYPE(ski->tree)) {
	case IDLN_ATTR_DCL:
      //#ifdef USE_LIBIDL_CODE
		cbe_ski_do_attr_dcl(ski);
        //#else
        cbe_ski_do_voyager_instance_vars(ski);
        cbe_ski_do_voyager_getdata_macros(ski);
        //#endif
		break;
	case IDLN_INTERFACE:
		cbe_ski_do_interface(ski);
        //        printf("%d: pass --->%d %d %d\n", __LINE__, ski->pass, whichPass, ulCurInterface);
		break;
	case IDLN_LIST:
		cbe_ski_do_list(ski);
		break;
	case IDLN_MODULE:
		cbe_ski_do_module(ski);
		break;
	case IDLN_OP_DCL:
		cbe_ski_do_op_dcl(ski);
		break;
	case IDLN_PARAM_DCL:
		cbe_ski_do_param_dcl(ski);
		break;
    case IDLN_CONST_DCL:
      /* Find the name of the metaclass for this class if any. */
      VoyagerExtractMetaClass(ski);
      /* Create enable defines for parameter checks. */
      VoyagerCreateParamCheckDefines(ski);
      break;
	default:
		break;
	}
}

static void
cbe_ski_do_module(CBESkelImplInfo *ski)
{
	CBESkelImplInfo subski = *ski;
	subski.tree = IDL_MODULE(ski->tree).definition_list;
	cbe_ski_do_list(&subski);
}

/* Returns 1 if the previous character written to f  */
/* was '\n', 0 otherwise. */
static inline unsigned char 
prev_char_is_nl(FILE *f)
{
        char c;
	long pos;
	size_t count;
        unsigned char retv = 0;

	pos = ftell(f);
	if (pos < sizeof(char)) 
		return 0; /* beginning of file */

        if (fseek(f, (-1)*sizeof(char), SEEK_CUR)) 
		goto out;

	count = fread((void*)&c, sizeof(char), 1, f);
        if (sizeof(char) == count) 
		retv = ('\n' == c) ? 1 : 0;
	
out:
	fseek(f, pos, SEEK_SET);
        return retv;
}

static void
cbe_ski_do_list(CBESkelImplInfo *ski)
{
	CBESkelImplInfo subski = *ski;
	IDL_tree curitem;

	for(curitem = ski->tree; curitem; curitem = IDL_LIST(curitem).next) {
		subski.tree = IDL_LIST(curitem).data;
		orbit_cbe_ski_process_piece(&subski);
		if(!prev_char_is_nl(ski->of))
			fprintf(ski->of, "\n");
	}
}

static void cbe_ski_do_voyager_instance_vars(CBESkelImplInfo *ski/*, IDL_tree current_interface , gboolean inherited*/)
{
	IDL_tree curitem;

	if(ski->pass == PASS_VOYAGER_INSTANCE) {
      for(curitem = IDL_ATTR_DCL(ski->tree).simple_declarations; curitem;
          curitem = IDL_LIST(curitem).next) {
        char* ptr;
        /* Indent type */
        fprintf(ski->of, "   ");
        orbit_cbe_write_typespec(ski->of, IDL_ATTR_DCL(ski->tree).param_type_spec);
        ulInstanceVarSize[ulCurInterface]+=orbit_cbe_get_typespec_size(IDL_ATTR_DCL(ski->tree).param_type_spec);

        /* Print the instance var name. To allow equally named vars in subclasses
           (which isn't supported by orbit-IDL) we use a macro in the *.idl file
           which adds a marker and the line num to the var name. Here we throw
           this unique name extension away. */
        if((ptr=strstr(IDL_IDENT(IDL_LIST(curitem).data).str, NOM_INSTANCEVAR_STRING))!=NULL)
          {
            /* This is our marked var. */
            *ptr='\0';
            fprintf(ski->of, " %s;\n", IDL_IDENT(IDL_LIST(curitem).data).str);
            *ptr='_';
          }
        else{
          fprintf(ski->of, " %s;\n", IDL_IDENT(IDL_LIST(curitem).data).str);
          fprintf(ski->of, "#warning Instance var %s defined without INSTANCEVAR() macro\n",
                  IDL_IDENT(IDL_LIST(curitem).data).str);
        }
      }
	}
}

static void cbe_ski_do_voyager_getdata_macros(CBESkelImplInfo *ski/*, IDL_tree current_interface , gboolean inherited*/)
{
	IDL_tree curitem;

	if(ski->pass == PASS_VOYAGER_GETDATA) {
      for(curitem = IDL_ATTR_DCL(ski->tree).simple_declarations; curitem;
          curitem = IDL_LIST(curitem).next) {
        char* ptr;
        /* Indent type */
        fprintf(ski->of,"#define ");
        /* Print the instance var name. To allow equally named vars in subclasses
           (which isn't supported by orbit-IDL) we use a macro in the *.idl file
           which adds a marker and the line num to the var name. Here we throw
           this unique name extension away. */
        if((ptr=strstr(IDL_IDENT(IDL_LIST(curitem).data).str, NOM_INSTANCEVAR_STRING))!=NULL)
          {
            *ptr='\0';
            fprintf(ski->of, " _%s (nomThis->%s)\n",
                    IDL_IDENT(IDL_LIST(curitem).data).str, IDL_IDENT(IDL_LIST(curitem).data).str);
            *ptr='_';
          }
        else{
          fprintf(ski->of, " _%s (nomThis->%s)\n", 
                  IDL_IDENT(IDL_LIST(curitem).data).str, IDL_IDENT(IDL_LIST(curitem).data).str);
          fprintf(ski->of, "#warning Instance var %s defined without INSTANCEVAR() macro\n",
                  IDL_IDENT(IDL_LIST(curitem).data).str);
        }
      }
	}
}

static void cbe_ski_do_voyager_classinfo_structure(CBESkelImplInfo *ski, gchar * className)
{

  /* Fill the info struct */
  fprintf(ski->of, "static nomStaticClassInfo %sSCI = {\n", className);
  fprintf(ski->of, "  0,               /* Version */\n");
  fprintf(ski->of, "  %ld, /* Number of static methods introduced by this class */\n",
          ulNumStaticMethods[ulCurInterface]);
  fprintf(ski->of, "  %ld,               /* Overrides */\n", ulNumOverridenMethods[ulCurInterface]);  
  fprintf(ski->of, "  %s_MajorVersion,\n", className);  
  fprintf(ski->of, "  %s_MinorVersion,\n", className);  
  fprintf(ski->of, "  %ld,               /* Instance data size */\n", ulInstanceVarSize[ulCurInterface]);  
  fprintf(ski->of, "  1,               /* Number of parents (multiple inheritance) */\n");  
  fprintf(ski->of, "  &nomIdString_%s,\n", className);  
  if(NULL!=gsMetaClassName[ulCurInterface])
      fprintf(ski->of, "  &nomIdStringMetaClass_%s,    /* Explicit meta id*/\n", className);
  else
    fprintf(ski->of, "  (nomID)0,    /* Explicit meta id*/\n");  
  fprintf(ski->of, "  (nomClassDataStructure*)&%sClassData,\n", className);  
  fprintf(ski->of, "  (nomCClassDataStructure*)&%sCClassData,\n", className);  
  fprintf(ski->of, "  (nomStaticMethodDesc*)&nomStaticMethods%s,\n", className);  
  if(0!=ulNumParentsInChain[ulCurInterface])
    fprintf(ski->of, "  nomParentClasses%s,\n", className);
  else
    fprintf(ski->of, "  (void*)0,\n");
  if(0!=ulNumParentsInChain[ulCurInterface])
    fprintf(ski->of, "  nomParentClassNames%s, /* Name of all the parent classes in chain */\n", className);
  else
    fprintf(ski->of, "  (void*)0,\n");
  fprintf(ski->of, "  %ld,                /* Number of parents in the chain of classes */\n", ulNumParentsInChain[ulCurInterface]);  
  if(0!=ulNumOverridenMethods[ulCurInterface])
    fprintf(ski->of, "  nomOverridenMethods%s, /* Name of all the parent classes in chain */\n", className);
  else
    fprintf(ski->of, "  (void*)0,\n");

  fprintf(ski->of, "};\n");

}

static void
cbe_ski_do_voyager_parent_idstrings(IDL_tree interface, CBESkelImplInfo *ski)
{
	char *id = NULL, *inherit_id = NULL; /* Quiet gcc */

	if(interface==ski->tree)
      return;
        
    id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(ski->tree).ident),
                                 "_", 0);
    inherit_id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(interface).ident),
                                         "_", 0);

    fprintf(ski->of, "  static char * nomIdString_Parent_%s = \"%s\";\n", inherit_id, inherit_id);
    ulNumParentsInChain[ulCurInterface]++;    
    g_free(id);
    g_free(inherit_id);
}

static void
cbe_ski_do_voyager_parent_names(IDL_tree interface, CBESkelImplInfo *ski)
{
	char *id = NULL, *inherit_id = NULL; /* Quiet gcc */

	if(interface==ski->tree)
      return;
        
    id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(ski->tree).ident),
                                 "_", 0);
    inherit_id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(interface).ident),
                                         "_", 0);

    fprintf(ski->of, "  \"%s\",\n", inherit_id);
    ulNumParentsInChain[ulCurInterface]++;    
    g_free(id);
    g_free(inherit_id);
}

static void
cbe_ski_do_voyager_parent_ids(IDL_tree interface, CBESkelImplInfo *ski)
{
	char *id = NULL, *inherit_id = NULL; /* Quiet gcc */

	if(interface==ski->tree)
      return;
        
    id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(ski->tree).ident),
                                 "_", 0);
    inherit_id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(interface).ident),
                                         "_", 0);

    fprintf(ski->of, "  &nomIdString_Parent_%s,\n", inherit_id);
    
    g_free(id);
    g_free(inherit_id);
}

static void
cbe_ski_do_voyager_parent_newclass(IDL_tree interface, CBESkelImplInfo *ski)
{
	char *id = NULL, *inherit_id = NULL; /* Quiet gcc */

	if(interface==ski->tree)
      return;
        
    id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(ski->tree).ident),
                                 "_", 0);
    inherit_id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(interface).ident),
                                         "_", 0);

    fprintf(ski->of, "  %sNewClass(%s_MajorVersion, %s_MinorVersion);\n",
            inherit_id, inherit_id, inherit_id);
    
    g_free(id);
    g_free(inherit_id);
}

static void 
cbe_ski_do_attr_dcl_internal(CBESkelImplInfo *ski, IDL_tree current_interface, gboolean inherited)
{
	IDL_tree curop, curitem;
	GString *attrname = g_string_new(NULL);
	CBESkelImplInfo subski = *ski;

	if(ski->pass == PASS_SERVANTS) {
      for(curitem = IDL_ATTR_DCL(ski->tree).simple_declarations; curitem;
          curitem = IDL_LIST(curitem).next) {
        /* Indent type */
        fprintf(ski->of, "   ");
			orbit_cbe_write_typespec(ski->of, IDL_ATTR_DCL(ski->tree).param_type_spec);
			fprintf(ski->of, " attr_%s;\n", IDL_IDENT(IDL_LIST(curitem).data).str);
		}
	}

	for(curitem = IDL_ATTR_DCL(ski->tree).simple_declarations;
	    curitem; curitem = IDL_LIST(curitem).next) {

		/* Fake the attribute get/set methods as operation declarations */
		IDL_tree ident, ns_data_save;
		int i;

		for (i = 0; i < 2; ++i) {

			if (i && IDL_ATTR_DCL(ski->tree).f_readonly)
				break;
			/* Output the operation on this attribute */
			g_string_printf(attrname, i ? "_set_%s" : "_get_%s",
					IDL_IDENT(IDL_LIST(curitem).data).str);
			ident = IDL_ident_new(g_strdup(attrname->str));
	    
			/* Tell the ident where our namespace node is, and request a return value
			   if this is the _get operation */
			IDL_IDENT_TO_NS(ident) = IDL_IDENT_TO_NS(IDL_LIST(curitem).data);
			curop = IDL_op_dcl_new(0, i == 0 ?
					       IDL_ATTR_DCL(ski->tree).param_type_spec : NULL,
					       ident, NULL, NULL, NULL);
	    
			curop->up = ski->tree->up;
			subski.tree = curop;
	    
			/* Save the namespace ident (IDL_GENTREE data) reference, assign
			   back to the temporary tree, output the operation, then restore
			   the namespace ident link */
			ns_data_save = IDL_GENTREE(IDL_IDENT_TO_NS(IDL_LIST(curitem).data)).data;
			IDL_GENTREE(IDL_IDENT_TO_NS(IDL_LIST(curitem).data)).data = ident;

			if (i) {
				/* The set routine also needs the value, so we
				   temporarily add that to the operation
				   declaration */
				IDL_OP_DCL(curop).parameter_dcls = IDL_list_new(
					IDL_param_dcl_new(IDL_PARAM_IN,
							  IDL_ATTR_DCL(ski->tree).param_type_spec,
							  IDL_ident_new(g_strdup("value"))));
			}
	    
			if(inherited==TRUE)
				cbe_ski_do_inherited_op_dcl(&subski, current_interface);
			else
				orbit_cbe_ski_process_piece(&subski);

			/* Restore the fake link to the original in the namespace */
			IDL_GENTREE(IDL_IDENT_TO_NS(IDL_LIST(curitem).data)).data = ns_data_save;

			if (i) {
				/* Free only what we've created for the fake node, so remove 
				   the attribute node element and then free the rest */
				IDL_PARAM_DCL(IDL_LIST(
						      IDL_OP_DCL(curop).parameter_dcls).data).param_type_spec = NULL;
			}
	    
			/* Remove what we've "borrowed" from ATTR_DCL from the
			   fake curop node then free the rest */
			IDL_OP_DCL(curop).op_type_spec = NULL;
			IDL_tree_free(curop);
		}
	}

	g_string_free(attrname, TRUE);
}

static void 
cbe_ski_do_attr_dcl(CBESkelImplInfo *ski)
{
	cbe_ski_do_attr_dcl_internal(ski, NULL, FALSE);
}

void
cbe_ski_do_inherited_attr_dcl(CBESkelImplInfo *ski, IDL_tree current_interface)
{
	cbe_ski_do_attr_dcl_internal(ski, current_interface, TRUE);
}


static void
cbe_ski_do_op_dcl(CBESkelImplInfo *ski)
{
	/* If you fix anything here, please also fix it in
	   cbe_ski_do_inherited_op_dcl(), which is almost a
	   cut-and-paste of this routine */

	char *id, *id2;
	IDL_tree curitem, op;
	int level;
	CBESkelImplInfo subski = *ski;

	switch(ski->pass) {
#if USE_LIBIDL_CODE    
	case PASS_PROTOS:
	case PASS_IMPLSTUBS:
#else
	case PASS_IMPLSTUBS:
      break;
	case PASS_PROTOS:
#endif
      {
        GString *gstr;
        gboolean bOverriden=FALSE;

		curitem = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, &level);
		g_assert(curitem);

		id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_OP_DCL(ski->tree).ident), "_", 0);    
		id2 = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(curitem).ident), "_", 0);

        gstr=g_string_new(IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);

        /* Check for our specially marked NOM-only methods. Don't output them here, they are handled
           specially. */
          if(!strstr(id, NOM_INSTANCEVAR_STRING) /*&& !strstr(id, NOM_OVERRIDE_STRING)*/)
          {
            char *ptr=NULL;
            char *ptr2=NULL;

            if((ptr=strstr(id, NOM_OVERRIDE_STRING))!=NULL)
              {
                *ptr='\0';
                bOverriden=TRUE;
              }
            if((ptr2=strstr(gstr->str, NOM_OVERRIDE_STRING))!=NULL)
              {
                *ptr2='\0';
              }

            if(bOverriden)
              fprintf(ski->of, "/*\n * Overriden method: %s\n */\n", gstr->str);     
            else
              fprintf(ski->of, "/*\n * New method: %s\n */\n", IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);     
            /* protect with #ifdef block  */
            if(PASS_PROTOS == ski->pass) 
              fprintf(ski->of, "#if !defined(_decl_impl_");
            else
              fprintf(ski->of, "#if !defined(_impl_");
            
            fprintf(ski->of, "%s_) /* %s, %s line %d */\n", id, __FILE__, __FUNCTION__, __LINE__);
            
            if(PASS_PROTOS == ski->pass) 
              fprintf(ski->of, "#define _decl_impl_");
            else
              fprintf(ski->of, "#define _impl_");
            
            fprintf(ski->of, "%s_ 1\n", id);
#if USE_LIBIDL_CODE    
            fprintf(ski->of, "static ");
            fprintf(ski->of, " impl_%s(impl_POA_%s *servant,\n", id, id2);
#endif

            /* Output the params */
            if(bOverriden)
              {
                /* Overriden method */
                fprintf(ski->of, "NOM_Scope ");
                op = ski->tree;
                VoyagerWriteOverridenMethodDeclaration(ski->of, op, "", FALSE);

                for(curitem = IDL_OP_DCL(ski->tree).parameter_dcls;
                    curitem; curitem = IDL_LIST(curitem).next) {
                  subski.tree = IDL_LIST(curitem).data;
                  orbit_cbe_ski_process_piece(&subski);
                }
              }
            else
              {
                fprintf(ski->of, "NOM_Scope ");

                orbit_cbe_write_param_typespec(ski->of, ski->tree);
                fprintf(ski->of, " NOMLINK impl_%s_%s(%s *nomSelf,\n",
                        id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str, id2);

                op = ski->tree;
                for(curitem = IDL_OP_DCL(ski->tree).parameter_dcls;
                    curitem; curitem = IDL_LIST(curitem).next) {
                  subski.tree = IDL_LIST(curitem).data;
                  orbit_cbe_ski_process_piece(&subski);
                }
              }
            
            if(IDL_OP_DCL(op).context_expr)
              fprintf(ski->of, "CORBA_Context ctx,\n");
            
            fprintf(ski->of, "CORBA_Environment *ev)");
#if USE_LIBIDL_CODE    
            if(ski->pass == PASS_IMPLSTUBS) {
              fprintf(ski->of, "\n{\n ");
              if(IDL_OP_DCL(op).op_type_spec) {
				orbit_cbe_write_param_typespec(ski->of, ski->tree);
				fprintf(ski->of, " retval;\n\n");
				fprintf(ski->of, " /* ------   insert method code here   ------ */\n");
				fprintf(ski->of, " /* ------ ---------- end ------------ ------ */\n");
				fprintf(ski->of, "\n return retval;\n");
              }
              else
                {	
                  fprintf(ski->of, " /* ------   insert method code here   ------ */\n");
                  fprintf(ski->of, " /* ------ ---------- end ------------ ------ */\n");
                }
              fprintf(ski->of, "}\n");
            } else /* PASS_PROTOS */
#endif
              fprintf(ski->of, ";\n");

            if(bOverriden)
              {
                IDL_tree tmptree;

                tmptree = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, NULL);; 
                fprintf(ski->of, "static char* nomIdString_%s_%s = \"",
                        id2, gstr->str);
                /* Output name of introducing class */
#if 0
                if(IDL_INTERFACE(tmptree).inheritance_spec) {
                  InheritedOutputInfo ioi;

                  ioi.of = ski->of;
                  ioi.realif = tmptree;
                  ioi.chrOverridenMethodName=gstr->str;
                  IDL_tree_traverse_parents(IDL_INTERFACE(tmptree).inheritance_spec,
                                            (GFunc)VoyagerOutputIntroducingClass, &ioi);
                }
#endif
                VoyagerOutputIntroducingClass(tmptree, ski, gstr);
                fprintf(ski->of, ":%s\";\n",gstr->str); /* Output the method name */

                fprintf(ski->of, "/* %s, %s line %d */\n", __FILE__, __FUNCTION__, __LINE__);
                fprintf(ski->of, "static nomMethodProc* %s_parent_resolved;\n", id);
                fprintf(ski->of, "#define %s_parent", id);

                /* output params for macro */
                fprintf(ski->of, "(nomSelf, ");
                if(IDL_INTERFACE(tmptree).inheritance_spec) {
                  InheritedOutputInfo ioi;

                  ioi.of = ski->of;
                  ioi.realif = tmptree;
                  ioi.chrOverridenMethodName=gstr->str;
                  IDL_tree_traverse_parents(IDL_INTERFACE(tmptree).inheritance_spec,
                                            (GFunc)VoyagerWriteParamsForParentCall, &ioi);
                }
                fprintf(ski->of, "ev)");
                fprintf(ski->of, " \\\n    (((");

                /* Output the typespec of the overriden proc */
                if(IDL_INTERFACE(tmptree).inheritance_spec) {
                  InheritedOutputInfo ioi;

                  ioi.of = ski->of;
                  ioi.realif = tmptree;
                  ioi.chrOverridenMethodName=gstr->str;
                  IDL_tree_traverse_parents(IDL_INTERFACE(tmptree).inheritance_spec,
                                            (GFunc)VoyagerOutputParentMethodSpec, &ioi);
                }
                fprintf(ski->of, ") \\\n    %s_parent_resolved)", id);
                /* output params for macro */
                // VoyagerWriteParamsForParentCall (ski->of, ski->tree );
                fprintf(ski->of, "((");
                /* Output name of introducing class */
#if 0
                if(IDL_INTERFACE(tmptree).inheritance_spec) {
                  InheritedOutputInfo ioi;

                  ioi.of = ski->of;
                  ioi.realif = tmptree;
                  ioi.chrOverridenMethodName=gstr->str;
                  IDL_tree_traverse_parents(IDL_INTERFACE(tmptree).inheritance_spec,
                                            (GFunc)VoyagerOutputIntroducingClass, &ioi);
                }
#endif
                VoyagerOutputIntroducingClass(tmptree, ski, gstr);
                fprintf(ski->of, "*)nomSelf, ");

                if(IDL_INTERFACE(tmptree).inheritance_spec) {
                  InheritedOutputInfo ioi;
                  
                  ioi.of = ski->of;
                  ioi.realif = tmptree;
                  ioi.chrOverridenMethodName=gstr->str;
                  IDL_tree_traverse_parents(IDL_INTERFACE(tmptree).inheritance_spec,
                                            (GFunc)VoyagerWriteParamsForParentCall, &ioi);
                }
                fprintf(ski->of, "ev)");
                fprintf(ski->of, ")\n");
              }
            else{
              fprintf(ski->of, "static char* nomIdString_%s_%s = nomMNDef_%s_%s;\n",
                      id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str,
                      id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);
              fprintf(ski->of, "static char* nomFullIdString_%s_%s = nomMNFullDef_%s_%s;\n",
                      id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str,
                      id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);
            }

            /* Output the parameter info for runtime type information */
            if(!bOverriden)
              {
                int a=0;
                IDL_tree tmptree;

                tmptree = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, NULL);

                fprintf(ski->of, "static nomParmInfo nomParm_%s = {\n", id);

                /* Output number of parameters */
                for(curitem = IDL_OP_DCL(ski->tree).parameter_dcls;
                    curitem; curitem = IDL_LIST(curitem).next) {
                  a++; /* Count parameters */
                }
                fprintf(ski->of, "  %d,  /* Number of parameters */\n", a);

                /* Output return type */
                fprintf(ski->of, "  /* Return type (%s: %s line %d)*/\n  \"", __FILE__, __FUNCTION__, __LINE__);
                orbit_cbe_write_param_typespec(ski->of, ski->tree);
                fprintf(ski->of, "\",\n  {");

                op = ski->tree;
                for(curitem = IDL_OP_DCL(ski->tree).parameter_dcls;
                    curitem; curitem = IDL_LIST(curitem).next) {
                  subski.tree = IDL_LIST(curitem).data;
                  
                  fprintf(ski->of, "  \"");
                  if(IDLN_PARAM_DCL==IDL_NODE_TYPE(subski.tree))
                    VoyagerOutputParamTypes(&subski);
                  fprintf(ski->of, "\",\n");
                }
                fprintf(ski->of, "}};\n");
              }

            /* Output a function for checking the parameters. Note that we only
               check the object pointer for now. */
            if(!bOverriden)
              {
                fprintf(ski->of, "#ifdef %s_ParmCheck\n", id);
                fprintf(ski->of, "NOMEXTERN ");                
                fprintf(ski->of, "gboolean NOMLINK parmCheckFunc_%s_%s(%s *nomSelf,\n",
                        id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str, id2);                
                op = ski->tree;
                for(curitem = IDL_OP_DCL(ski->tree).parameter_dcls;
                    curitem; curitem = IDL_LIST(curitem).next) {
                  subski.tree = IDL_LIST(curitem).data;
                  orbit_cbe_ski_process_piece(&subski);
                }
                        
                if(IDL_OP_DCL(op).context_expr)
                  fprintf(ski->of, "CORBA_Context ctx,\n");            
                fprintf(ski->of, "CORBA_Environment *ev)");

                fprintf(ski->of, "{\n");

                fprintf(ski->of, "if(!nomIsObj(nomSelf) || !_nomIsANoClsCheck(nomSelf , %sClassData.classObject, NULLHANDLE))\n", id2);
                fprintf(ski->of, "  {\n");
                fprintf(ski->of, "  nomPrintObjectPointerError(nomSelf, \"%s\", \"%s\");\n", id2, id);
                fprintf(ski->of, "  return FALSE;\n");
                fprintf(ski->of, "  }\n");
                fprintf(ski->of, "  g_message(\"%%s: parameter check for %%s...\", __FUNCTION__, _nomGetClassName(nomSelf, NULLHANDLE));\n");
                fprintf(ski->of, "  return TRUE;\n");
                fprintf(ski->of, "}\n");
                fprintf(ski->of, "#endif\n");
              }


            if(ptr!=NULL)
                *ptr='_';

            if(ptr2!=NULL)
                *ptr2='_';

            g_string_free(gstr, TRUE);
            g_free(id); g_free(id2);

            fprintf(ski->of, "#endif\n\n"); /* end of protective #ifdef block */
          }
        else{ /* NOM_INSTANCEVAR_STRING... */
          g_free(id); g_free(id2);
        }
		break; /* End PASS_PROTOS | PASS_IMPLSTUBS */
      }
	case PASS_EPVS:
#if USE_LIBIDL_CODE    
		id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_OP_DCL(ski->tree).ident), "_", 0);
		fprintf(ski->of, "(gpointer)&impl_%s,\n", id);
		g_free(id);
#endif
		break;
    case PASS_VOYAGER_STATICMETHODS:
      {
        /* Build the structs for the static methods array. */
		curitem = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, &level);
		g_assert(curitem);

		id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_OP_DCL(ski->tree).ident), "_", 0);    
		id2 = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(curitem).ident), "_", 0);

        /* Check for our specially marked NOM-only methods. Don't output them, they are handled
           specially. */
          if(!strstr(id, NOM_INSTANCEVAR_STRING) &&
             !strstr(id, NOM_OVERRIDE_STRING))
          {
            fprintf(ski->of, "{   /* (%s, %s line %d) */\n", __FILE__, __FUNCTION__, __LINE__);
            fprintf(ski->of, "  &%sClassData.%s,\n", id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);
            fprintf(ski->of, "  (nomID)&nomIdString_%s_%s,\n", id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);
            fprintf(ski->of, "  &nomFullIdString_%s_%s,  /* char *chrMethodDescriptor */\n",
                    id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);
            fprintf(ski->of, "  (nomMethodProc*)  impl_%s_%s,\n", id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);
            fprintf(ski->of, "  &nomParm_%s_%s\n", id2, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);
            fprintf(ski->of, "},\n");

            ulNumStaticMethods[ulCurInterface]++;

            g_free(id); g_free(id2);
          }
        else{ /* NOM_OVERRIDE_STRING... */
          g_free(id); g_free(id2);
        }
		break; /* End  */
      }
    case PASS_VOYAGER_OVERRIDEN_METHODTAB:
      {
        char *ptr;

		curitem = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, &level);
		g_assert(curitem);

		id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_OP_DCL(ski->tree).ident), "_", 0);
        //   id2 = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(curitem).ident), "_", 0);
        id2 = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_OP_DCL(ski->tree).ident), "_", 0);

        if((ptr=strstr(id, NOM_OVERRIDE_STRING))!=NULL)
          {
            /*            fprintf(ski->of, "%s\n",id); */
            /* This is our marked var. */
            *ptr='\0';
            //            fprintf(ski->of, " %s;\n", IDL_IDENT(IDL_LIST(curitem).data).str);
            fprintf(ski->of, "   /* (%s, %s line %d) */\n", __FILE__, __FUNCTION__, __LINE__);
            //fprintf(ski->of, "  static gchar* string%s_overriden = \"", id);
            *ptr='_';

            fprintf(ski->of, "  {\n");
            if((ptr=strstr(id2, NOM_OVERRIDE_STRING))!=NULL){
              *ptr='\0';
              fprintf(ski->of, "    &nomIdString_%s, /* line %d */\n", id2, __LINE__);
              fprintf(ski->of, "    (nomMethodProc*) impl_%s,\n", id2);
              fprintf(ski->of, "    &%s_parent_resolved\n", id2);
              *ptr='_';
            }
            fprintf(ski->of, "  },\n");
            //fprintf(ski->of, "  static gchar* string%s_overriden = \":%s %s\";\n",
            //      id, IDL_IDENT(IDL_LIST(curitem).data).str, IDL_IDENT(IDL_OP_DCL(ski->tree).ident).str);

            //fprintf(ski->of, "\n");
            ulNumOverridenMethods[ulCurInterface]++;
          }

        g_free(id); //g_free(id2);
        break;
      }
    case PASS_VOYAGER_OVERRIDEN_METHODS:
      {

        break;
      }
	default:
		break;
	}
}

static void
cbe_ski_do_inherited_op_dcl(CBESkelImplInfo *ski, IDL_tree current_interface)
{
	char *id, *id2;
	IDL_tree ident, curitem, intf, op;
	int level;
	CBESkelImplInfo subski = *ski;

	id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(current_interface).ident), "_", 0);
	intf = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, NULL);
	id2 = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(intf).ident), "_", 0);

	ident=IDL_OP_DCL(ski->tree).ident;
	g_assert(ident);

	switch(ski->pass) {
#if USE_LIBIDL_CODE
	case PASS_PROTOS:
	case PASS_IMPLSTUBS:
#else
	case PASS_IMPLSTUBS:
      break;
	case PASS_PROTOS:
#endif
		curitem = IDL_get_parent_node(ski->tree, IDLN_INTERFACE, &level);
		g_assert(curitem);


        /* Check for our specially marked NOM-only methods. Don't output them, they are handled
           specially. */
        if(!strstr(IDL_IDENT(ident).str, NOM_INSTANCEVAR_STRING) &&
           !strstr(IDL_IDENT(ident).str, NOM_OVERRIDE_STRING))
          {
            fprintf(ski->of, "/* FIXME: We don't need these for Voyager? %s, %s line %d */\n",
                    __FILE__, __FUNCTION__, __LINE__);
            /* protect with #ifdef block  */
            if(PASS_PROTOS == ski->pass) 
              fprintf(ski->of, "#if !defined(_decl_impl_");
            else
              fprintf(ski->of, "#if !defined(_impl_");
            fprintf(ski->of, "%s_%s_)\n", id, IDL_IDENT(ident).str);
            
            if(PASS_PROTOS == ski->pass) 
              fprintf(ski->of, "#define _decl_impl_");
            else
              fprintf(ski->of, "#define _impl_");
            fprintf(ski->of, "%s_%s_ 1\n", id, IDL_IDENT(ident).str);
#if USE_LIBIDL_CODE
            fprintf(ski->of, "static ");
#endif
            orbit_cbe_write_param_typespec(ski->of, ski->tree);
#if USE_LIBIDL_CODE
    		fprintf(ski->of, " impl_%s_%s(impl_POA_%s *servant,\n", id, IDL_IDENT(ident).str, id);
#else
        	fprintf(ski->of, " NOMLINK impl_%s_%s(%s *nomSelf,\n", id, IDL_IDENT(ident).str, id);
#endif
            
            op = ski->tree;
            for(curitem = IDL_OP_DCL(ski->tree).parameter_dcls;
                curitem; curitem = IDL_LIST(curitem).next) {
              subski.tree = IDL_LIST(curitem).data;
              orbit_cbe_ski_process_piece(&subski);
            }
            
            if(IDL_OP_DCL(op).context_expr)
              fprintf(ski->of, "CORBA_Context ctx,\n");
            
            fprintf(ski->of, "CORBA_Environment *ev)");
            if(ski->pass == PASS_IMPLSTUBS) {
              fprintf(ski->of, "\n{\n ");
              if(IDL_OP_DCL(op).op_type_spec) {
				orbit_cbe_write_param_typespec(ski->of, ski->tree);
				fprintf(ski->of, " retval;\n\n");
				fprintf(ski->of, " /* ------   insert method code here   ------ */\n");
				fprintf(ski->of, " /* ------ ---------- end ------------ ------ */\n");
				fprintf(ski->of, " \nreturn retval;\n");
              }
              else
                {	
                  fprintf(ski->of, " /* ------   insert method code here   ------ */\n");
                  fprintf(ski->of, " /* ------ ---------- end ------------ ------ */\n");
                }
              fprintf(ski->of, "}\n");
            } else /* PASS_PROTOS */
              fprintf(ski->of, ";\n");
            
            fprintf(ski->of, "#endif\n\n"); /* end of protective #ifdef block */
          }/* NOM_OVERRIDE_STRING... */

		break; /* End PASS_PROTOS | PASS_IMPLSTUBS */
	case PASS_EPVS:
#if USE_LIBIDL_CODE
		ident=IDL_OP_DCL(ski->tree).ident;
		g_assert(ident);

		fprintf(ski->of, "(gpointer)&impl_%s_%s,\n", id, IDL_IDENT(ident).str);
#endif
	default:
		break;
	}

	g_free(id);
	g_free(id2);
}

static void
cbe_ski_do_param_dcl(CBESkelImplInfo *ski)
{
	orbit_cbe_write_param_typespec(ski->of, ski->tree);
	fprintf(ski->of, " %s,\n", IDL_IDENT(IDL_PARAM_DCL(ski->tree).simple_declarator).str);
}

static void
cbe_ski_do_interface_vepv_entry(IDL_tree interface, CBESkelImplInfo *ski)
{
	char *id, *inherit_id;

	if(interface==ski->tree) {
		id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(ski->tree).ident), "_", 0);
		fprintf(ski->of, "&impl_%s_epv,\n", id);
		g_free(id);
		return;
	}

	id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(ski->tree).ident), "_", 0);
	inherit_id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(interface).ident),
					     "_", 0);
	fprintf(ski->of, "&impl_%s_%s_epv,\n", id, inherit_id);

	g_free(id);
	g_free(inherit_id);
}

static void
cbe_ski_do_inherited_methods(IDL_tree interface, CBESkelImplInfo *ski)
{
	CBESkelImplInfo subski= *ski;
	IDL_tree curitem;
	char *id = NULL, *inherit_id = NULL; /* Quiet gcc */

	if(interface==ski->tree)
		return;

	if(ski->pass==PASS_EPVS) {
		id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(ski->tree).ident),
					     "_", 0);
		inherit_id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(interface).ident),
						     "_", 0);
		/* protect with #ifdef block  */
		fprintf(ski->of, "#if !defined(_impl_%s_%s_epv_)\n", id, inherit_id);
		fprintf(ski->of, "#define _impl_%s_%s_epv_ 1\n", id, inherit_id);
		fprintf(ski->of, "static POA_%s__epv impl_%s_%s_epv = {\nNULL, /* _private */\n", inherit_id, id, inherit_id);
	}

	for(curitem = IDL_INTERFACE(interface).body; curitem; curitem=IDL_LIST(curitem).next) {
		subski.tree=IDL_LIST(curitem).data;

		switch(IDL_NODE_TYPE(IDL_LIST(curitem).data)) {
		case IDLN_OP_DCL:
			cbe_ski_do_inherited_op_dcl(&subski, ski->tree);
			break;
		case IDLN_ATTR_DCL:
			cbe_ski_do_inherited_attr_dcl(&subski, ski->tree);
			break;
		default:
			break;
		}
	}

	if(ski->pass==PASS_EPVS) {
		fprintf(ski->of, "};\n"); 
		fprintf(ski->of, "#endif\n"); /* end of protective #ifdef block */

		g_free(id);
		g_free(inherit_id);
	}
}

/*
  CW: When doing a pass we first end here for each interface. By calling
  cbe_ski_do_list() all nodes are traversed and the subfunctions are called
  accordingly.

 */
static void
cbe_ski_do_interface(CBESkelImplInfo *ski)
{
	char *id;
	CBESkelImplInfo subski = *ski;

	id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(ski->tree).ident), "_", 0);

	switch(ski->pass) {
    case PASS_VOYAGER_OVERRIDEN_METHODTAB:
      {
        fprintf(ski->of, "/* Table of the overriden methods by this class */\n");
        fprintf(ski->of, "static nomOverridenMethodDesc nomOverridenMethods%s[] = {\n", id);        
		subski.tree = IDL_INTERFACE(ski->tree).body;
        cbe_ski_do_list(&subski);
		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);
        
        fprintf(ski->of, "};\n\n");
        break;
      }
    case PASS_VOYAGER_OVERRIDEN_METHODS:
      {
        fprintf(ski->of, "/* Description of the overriden methods by this class */\n");
        
		subski.tree = IDL_INTERFACE(ski->tree).body;
        cbe_ski_do_list(&subski);
		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);
        
        break;
      }
    case PASS_VOYAGER_CLSDATA:
      {
        /* Create the static class data structs */
        fprintf(ski->of, "/* %s, %s line %d */\n", __FILE__, __FUNCTION__, __LINE__);
        fprintf(ski->of, "#ifdef NOM_%s_IMPLEMENTATION_FILE\n\n", id);
        fprintf(ski->of, "struct %sClassDataStructure %sClassData = {0};\n", id, id);
        fprintf(ski->of, "static struct %sCClassDataStructure %sCClassData = {0};\n\n", id, id);

        break;
      }
    case PASS_VOYAGER_NEWCLASS:
      {
        IDL_tree tmptree;
        char* id2;

        if(NULL!=gsMetaClassName[ulCurInterface]){
          char* chrTemp;
          chrTemp=g_ascii_strdown(gsMetaClassName[ulCurInterface]->str, -1);

          fprintf(ski->of, "\n#include \"%s.h\"\n\n", chrTemp);
          g_free(chrTemp);
        }
        fprintf(ski->of, "#include \"nomgc.h\"\n");
        fprintf(ski->of, "NOMClass* NOMLINK %sNewClass(gulong ulMajor, gulong ulMinor)\n{\n", id);
        fprintf(ski->of, "  NOMClass* result;\n\n");

        fprintf(ski->of, "#ifdef __OS2__\n");
        fprintf(ski->of, "  gulong ulObj, ulOffset;\n  gchar thePath[CCHMAXPATH];\n  HMODULE hModule;\n\n");
        fprintf(ski->of,
                "  g_assert(DosQueryModFromEIP( &hModule, &ulObj, CCHMAXPATH, thePath, &ulOffset, (ULONG)%sNewClass)==0);\n", id);
        fprintf(ski->of, "  g_strlcat(thePath, \".DLL\", sizeof(thePath));\n");
        fprintf(ski->of, "  if(!nomQueryUsingNameIsDLLRegistered(thePath))\n    {\n");
        fprintf(ski->of, "    HREGDLL hReg=nomBeginRegisterDLLWithGC();\n");
        fprintf(ski->of, "    g_assert(nomRegisterDLLByName(hReg, thePath));\n");
        fprintf(ski->of, "    nomEndRegisterDLLWithGC(hReg);\n    }\n");
        fprintf(ski->of, "#else\n#error DLL must be registered with the garbage collector!\n#endif\n\n");

        /* Make sure meta class is created if specified by the user */
        if(NULL!=gsMetaClassName[ulCurInterface]){
          fprintf(ski->of, "  /* Create the metaclass */\n");
          fprintf(ski->of, "  %sNewClass(%s_MajorVersion, %s_MinorVersion);\n",
                  gsMetaClassName[ulCurInterface]->str, gsMetaClassName[ulCurInterface]->str, gsMetaClassName[ulCurInterface]->str);
          /* Free the string */
          g_string_free(gsMetaClassName[ulCurInterface], TRUE);
          gsMetaClassName[ulCurInterface]=(void*)0;
        }
        /* Do parent */
        /* The following traverses the whole parent tree but not the parents 
           from multiple inheritace :
           
           IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_voyager_parent_newclass, ski);
        */
        tmptree = IDL_LIST(ski->tree).prev; 
        if(tmptree){
          /* id2 will contain the name of the direct parent */
          id2 = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(tmptree).ident), "_", 0);
          fprintf(ski->of, "  %sNewClass(%s_MajorVersion, %s_MinorVersion);\n",
                  id2, id2, id2);
          g_free(id2);
        }
        fprintf(ski->of, "  result = nomBuildClass(1, &%sSCI, ulMajor, ulMinor);\n\n", id);
        fprintf(ski->of, "  return result;\n");
        fprintf(ski->of, "};\n\n");

        break;
      }
    case PASS_VOYAGER_METACLASS:
      {
        //   gsMetaClassName[ulCurInterface]=(void*)0;
		subski.tree = IDL_INTERFACE(ski->tree).body;
        cbe_ski_do_list(&subski);
		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);

        if(NULL!=gsMetaClassName[ulCurInterface])
          {
            /* Metaclass id */
            fprintf(ski->of, "/* The meta class this class is using (line %d %s) */\n", __LINE__, __FILE__);
            fprintf(ski->of, "static char * nomIdStringMetaClass_%s = \"%s\";\n\n",  id, gsMetaClassName[ulCurInterface]->str);
          }
        break;
      }
    case PASS_VOYAGER_PARMCHECK:
      {
		subski.tree = IDL_INTERFACE(ski->tree).body;
        cbe_ski_do_list(&subski);
        /* Output parameter check defines */
		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);
        /* Output generic object check function */
        VoyagerCreateObjectCheckFunction(id, ski);
        break;
      }
    case PASS_VOYAGER_CLASSINFO:
      {
        IDL_tree tmptree;
        char* id2;

        printf("%d: --->%d\n", __LINE__, ulCurInterface);        

        /* id contains the class name */
        fprintf(ski->of, "/* Identify this class */\n");
        /* ID of this class */
        fprintf(ski->of, "static char * nomIdString_%s = \"%s\";\n", id, id);

        tmptree = IDL_LIST(ski->tree).prev; 

        if(tmptree){
          /* We have some parent */
          
          /* id2 will contain the name of the direct parent */
          id2 = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(tmptree).ident), "_", 0);

          fprintf(ski->of, "\n/* Array of parent names */\nstatic char* nomParentClassNames%s[]=\n{\n", id);
          /* The following traverses the whole parent tree but not the parents 
             from multiple inheritace */
          //       IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_voyager_parent_idstrings, ski);
          
          IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_voyager_parent_names, ski);
          fprintf(ski->of, "};\n\n");
          
          /* IDs of parent class(es) */
          fprintf(ski->of, "static char * nomIdString_Parent_%s = \"%s\";\n\n", id2, id2);
          
          fprintf(ski->of, "\n/* Array of parent IDs */\nstatic nomID nomParentClasses%s[]=\n{\n", id);
          /* The following traverses the whole parent tree but not the parents 
             from multiple inheritace 
             
             IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_voyager_parent_ids, ski);
          */
          fprintf(ski->of, "  &nomIdString_Parent_%s,\n", id2);
          g_free(id2);
          fprintf(ski->of, "};\n\n");
        }
        cbe_ski_do_voyager_classinfo_structure(ski, id);

        break;
      }
    case PASS_VOYAGER_STATICMETHODS:
      {
        fprintf(ski->of, "/* Description of the static methods introduced by this class */\n");
        fprintf(ski->of, "static nomStaticMethodDesc nomStaticMethods%s[] = {\n", id);
 
		subski.tree = IDL_INTERFACE(ski->tree).body;
        cbe_ski_do_list(&subski);
		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);
        
        fprintf(ski->of, "};\n");
        
        break;
      }
	case PASS_VOYAGER_GETDATA:
      {
        CBESkelImplInfo sski;
        IDL_tree curitem;
        gboolean bFlag=FALSE;

        /* Make sure we only create this struct for objects which do have instance vars */
        for(curitem = IDL_INTERFACE(ski->tree).body; curitem; curitem = IDL_LIST(curitem).next) {
          sski.tree = IDL_LIST(curitem).data;
          if(IDL_NODE_TYPE(sski.tree)==IDLN_ATTR_DCL)
            bFlag=TRUE;
        }
        
        if(bFlag){
          /* protect with #ifdef block  */
          fprintf(ski->of, "/* These macros are created in %s() (%s) */\n", __FUNCTION__, __FILE__);
          fprintf(ski->of, "#if !defined(_getmacros_%s_Data)\n", id);
          fprintf(ski->of, "#define _getmacros_%s_Data 1\n", id);
          
          /* Get data macro */
          fprintf(ski->of, "\n/*\n * Get data macros for %s\n */\n", id);
          fprintf(ski->of, "typedef %sData* NOMLINK nomTP_%s_DataThunk(void*);\n", id, id);
          fprintf(ski->of, "typedef nomTP_%s_DataThunk *nomTD_%s_DataThunk;\n", id, id);
          fprintf(ski->of, "#define %sGetData(nomSelf) \\\n", id);
          fprintf(ski->of, "   (((nomTD_%s_DataThunk)(%sCClassData.instanceDataToken))(nomSelf))", id, id);
          /* Now do macros for each var */
          
          subski.tree = IDL_INTERFACE(ski->tree).body;
          cbe_ski_do_list(&subski);
          IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);
          
          fprintf(ski->of, "#endif /* _getmacros_%s_Data */\n\n", id); /* end of protective #ifdef block */
        }
		break;
      }

	case PASS_VOYAGER_INSTANCE:
      {
        CBESkelImplInfo sski;
        IDL_tree curitem;
        gboolean bFlag=FALSE;

        /* Make sure we only create this struct for objects which do have instance vars */
        for(curitem = IDL_INTERFACE(ski->tree).body; curitem; curitem = IDL_LIST(curitem).next) {
          sski.tree = IDL_LIST(curitem).data;
          if(IDL_NODE_TYPE(sski.tree)==IDLN_ATTR_DCL)
            bFlag=TRUE;
        }
        
        if(bFlag){
          /* protect with #ifdef block  */
          fprintf(ski->of, "/* This structure is created in %s() (%s) */\n", __FUNCTION__, __FILE__);
          fprintf(ski->of, "#if !defined(_typedef_%s_Data)\n", id);
          fprintf(ski->of, "#define _typedef_%s_Data 1\n", id);
          
          /* Instance data struct */
          fprintf(ski->of, "\n/*\n * Instance variables for %s\n */\n", id);
          fprintf(ski->of, "typedef struct {\n");
          subski.tree = IDL_INTERFACE(ski->tree).body;
          cbe_ski_do_list(&subski);
          IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);
          fprintf(ski->of, "} %sData;\n", id);
          
          fprintf(ski->of, "#endif /* _typedef_%s_Data*/\n\n", id); /* end of protective #ifdef block */
        }
		break;
      }
	case PASS_SERVANTS:
#ifdef USE_LIBIDL_CODE
		/* protect with #ifdef block  */
		fprintf(ski->of, "#if !defined(_typedef_impl_POA_%s_)\n", id);
		fprintf(ski->of, "#define _typedef_impl_POA_%s_ 1\n", id);
		fprintf(ski->of, "typedef struct {\nPOA_%s servant;\nPortableServer_POA poa;\n", id);
		subski.tree = IDL_INTERFACE(ski->tree).body;
		cbe_ski_do_list(&subski);
		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);
		fprintf(ski->of, "   /* ------ add private attributes here ------ */\n");
		fprintf(ski->of, "   /* ------ ---------- end ------------ ------ */\n");
		fprintf(ski->of, "} impl_POA_%s;\n", id);
		fprintf(ski->of, "#endif\n\n"); /* end of protective #ifdef block */
#endif
		break;
	case PASS_EPVS:
#ifdef USE_LIBIDL_CODE
		/* protect with #ifdef block  */
		fprintf(ski->of, "#if !defined(_impl_%s_base_epv_)\n", id);
		fprintf(ski->of, "#define _impl_%s_base_epv_ 1\n", id);
		fprintf(ski->of, "static PortableServer_ServantBase__epv impl_%s_base_epv = {\n", id);
		fprintf(ski->of, "NULL,             /* _private data */\n");
		fprintf(ski->of, "(gpointer) & impl_%s__destroy, /* finalize routine */\n", id);
		fprintf(ski->of, "NULL,             /* default_POA routine */\n");
		fprintf(ski->of, "};\n");
		fprintf(ski->of, "#endif\n\n"); /* end of protective #ifdef block */

		/* protect with #ifdef block  */
		fprintf(ski->of, "#if !defined(_impl_%s_epv_)\n", id);
		fprintf(ski->of, "#define _impl_%s_epv_ 1\n", id);
		fprintf(ski->of, "static POA_%s__epv impl_%s_epv = {\nNULL, /* _private */\n", id, id);
		subski.tree = IDL_INTERFACE(ski->tree).body;
		cbe_ski_do_list(&subski);
		fprintf(ski->of, "};\n");
		fprintf(ski->of, "#endif\n\n"); /* end of protective #ifdef block */

		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);
#endif
		break;
	case PASS_VEPVS:
#if USE_LIBIDL_CODE
		/* protect with #ifdef block  */
		fprintf(ski->of, "#if !defined(_impl_%s_vepv_)\n", id);
		fprintf(ski->of, "#define _impl_%s_vepv_ 1\n", id);

		fprintf(ski->of, "static POA_%s__vepv impl_%s_vepv = {\n", id, id);
		fprintf(ski->of, "&impl_%s_base_epv,\n", id);
		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_interface_vepv_entry, ski);
		fprintf(ski->of, "};\n");

		fprintf(ski->of, "#endif\n\n"); /* end of protective #ifdef block */
#endif
		break;
	case PASS_IMPLSTUBS:
#if USE_LIBIDL_CODE
		/* protect __create with #ifdef block  */
		fprintf(ski->of, "#if !defined(_impl_%s__create_)\n", id);
		fprintf(ski->of, "#define _impl_%s__create_ 1\n", id);
		fprintf(ski->of, "static %s impl_%s__create(PortableServer_POA poa, CORBA_Environment *ev)\n", id, id);
		fprintf(ski->of, "{\n%s retval;\nimpl_POA_%s *newservant;\nPortableServer_ObjectId *objid;\n\n", id, id);
		fprintf(ski->of, "newservant = g_new0(impl_POA_%s, 1);\n", id);
		fprintf(ski->of, "newservant->servant.vepv = &impl_%s_vepv;\n", id);
		fprintf(ski->of, "newservant->poa = (PortableServer_POA) CORBA_Object_duplicate((CORBA_Object)poa, ev);\n");
		fprintf(ski->of, "POA_%s__init((PortableServer_Servant)newservant, ev);\n", id);
    		fprintf(ski->of, "   /* Before servant is going to be activated all\n");
		fprintf(ski->of, "    * private attributes must be initialized.  */\n"); 
		fprintf(ski->of, "\n");
		fprintf(ski->of, "   /* ------ init private attributes here ------ */\n");
		fprintf(ski->of, "   /* ------ ---------- end ------------- ------ */\n");
		fprintf(ski->of, "\n");
		fprintf(ski->of, "objid = PortableServer_POA_activate_object(poa, newservant, ev);\n");
		fprintf(ski->of, "CORBA_free(objid);\n");
		fprintf(ski->of, "retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);\n");
		fprintf(ski->of, "\nreturn retval;\n}\n");
		fprintf(ski->of, "#endif\n\n"); /* end of protective #ifdef block */

		/* protect __destroy with #ifdef block  */
		fprintf(ski->of, "#if !defined(_impl_%s__destroy_)\n", id);
		fprintf(ski->of, "#define _impl_%s__destroy_ 1\n", id);
		fprintf(ski->of, "static void\nimpl_%s__destroy(impl_POA_%s *servant, CORBA_Environment *ev)\n{\n", id, id);
		fprintf(ski->of, "    CORBA_Object_release ((CORBA_Object) servant->poa, ev);\n\n");
		fprintf(ski->of, "    /* No further remote method calls are delegated to \n");
		fprintf(ski->of, "    * servant and you may free your private attributes. */\n");
		fprintf(ski->of, "   /* ------ free private attributes here ------ */\n");
		fprintf(ski->of, "   /* ------ ---------- end ------------- ------ */\n");
		fprintf(ski->of, "\nPOA_%s__fini((PortableServer_Servant)servant, ev);\n", id);
		fprintf(ski->of, "\ng_free (servant);\n");
		fprintf(ski->of, "}\n");
		fprintf(ski->of, "#endif\n\n"); /* end of protective #ifdef block */
#endif
		subski.tree = IDL_INTERFACE(ski->tree).body;
		cbe_ski_do_list(&subski);
		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);
		break;
	case PASS_PROTOS:
#if USE_LIBIDL_CODE
		/* protect __destroy declaration with #ifdef block  */
		fprintf(ski->of, "#if !defined(_decl_impl_%s__destroy_)\n", id);
		fprintf(ski->of, "#define _decl_impl_%s__destroy_ 1\n", id);
		fprintf(ski->of, "static void impl_%s__destroy(impl_POA_%s *servant,\nCORBA_Environment *ev);\n", id, id);
		fprintf(ski->of, "#endif\n\n"); /* end of protective #ifdef block */
#endif
		subski.tree = IDL_INTERFACE(ski->tree).body;
		cbe_ski_do_list(&subski);
		IDL_tree_traverse_parents(ski->tree, (GFunc)&cbe_ski_do_inherited_methods, ski);

		break;
	default:
		break;
	}

	g_free(id);
}
